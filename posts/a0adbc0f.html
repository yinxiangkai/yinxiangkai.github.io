<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NTT（快速数论变换） | 豈風</title><meta name="author" content="豈"><meta name="copyright" content="豈"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文主要是介绍了NTT算法的基础知识，并扩展了四步NTT，并介绍了相应的优化思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="NTT（快速数论变换）">
<meta property="og:url" content="http://qifeng.xyz/posts/a0adbc0f.html">
<meta property="og:site_name" content="豈風">
<meta property="og:description" content="本文主要是介绍了NTT算法的基础知识，并扩展了四步NTT，并介绍了相应的优化思路。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410102135290.png">
<meta property="article:published_time" content="2024-01-23T06:14:41.000Z">
<meta property="article:modified_time" content="2024-07-12T06:16:25.000Z">
<meta property="article:author" content="豈">
<meta property="article:tag" content="NTT">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410102135290.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://qifeng.xyz/posts/a0adbc0f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-5uvXaaQmiY"/><meta name="google-site-verification" content="xxxxx"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NTT（快速数论变换）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-12 14:16:25'
}</script><link rel="stylesheet" href="/css/icon.css"><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="豈風" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/android-chrome-512x512.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/life/"><i class="fa-fw fas fa-utensils"></i><span> 生活</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://onedrive-blue.vercel.app/"><i class="fa-fw fas fa-cloud"></i><span> 网盘</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://example.com/image.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="豈風"><img class="site-icon" src="/img/apple-touch-icon.png" alt="Logo"/><span class="site-name">豈風</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/life/"><i class="fa-fw fas fa-utensils"></i><span> 生活</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://onedrive-blue.vercel.app/"><i class="fa-fw fas fa-cloud"></i><span> 网盘</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">NTT（快速数论变换）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-23T06:14:41.000Z" title="发表于 2024-01-23 14:14:41">2024-01-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-12T06:16:25.000Z" title="更新于 2024-07-12 14:16:25">2024-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NTT（快速数论变换）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/a0adbc0f.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1 算法介绍"></a>1 算法介绍</h2><h3 id="1-1-多项式乘法引入"><a href="#1-1-多项式乘法引入" class="headerlink" title="1.1 多项式乘法引入"></a>1.1 多项式乘法引入</h3><h4 id="1-1-1-多项式的两种表示方法"><a href="#1-1-1-多项式的两种表示方法" class="headerlink" title="1.1.1 多项式的两种表示方法"></a>1.1.1 多项式的两种表示方法</h4><p>一般 $n$ 次多项式如公式（1）所示。多项式具有两种表示方法分别是系数表示法和点值表示法。</p>
<script type="math/tex; mode=display">
\begin{equation}
A(x)=a_0+a_1x^1+a_2x^2+\ldots +a_{n-1}x^{n-1}+a_nx^n=\sum^{n}_{i=0}a_ix^i
\end{equation}</script><h5 id="系数表示法："><a href="#系数表示法：" class="headerlink" title="系数表示法："></a>系数表示法：</h5><p>任意多项式都可以通过一组系数所确定，而这组系数所组成的向量也叫做系数向量,通过系数向量表示一个多项的方式也叫做系数表示法。例如公式（1）中 $A(x)$ 的系数向量为：$\mathbf{a}=[a_0  ,a_1,\ldots,a_{n-1},a_n]$。</p>
<h5 id="点值表示法："><a href="#点值表示法：" class="headerlink" title="点值表示法："></a>点值表示法：</h5><p>对于一个已知的多项式例如公式（1）中的 $A(x)$ ，将 $x_i$ 代进去可以得到一个确定的值 $y_i$ ，如：$y_0=A(x_0)$ 。且可将 $(x_0,y_0)$ 看作是坐标系上的一个点。可将任意多（互不相等）的自变量 $( x_1,x_2,\ldots,x_{n-1}, x_n)$ 代入到 $A(x)$ 中，从而得到更多的点：$(x_1,y_1),(x_2,y_2),\ldots(x_n,y_n)$。通过 n+1 个不同点组成的点集 $P=\{(x_0,y_0),(x_1,y_1),\ldots,(x_n,y_n)\} $ ，唯一确定一个 n 次多项式，该方式也叫做多项式的点值表示法。</p>
<h4 id="1-1-2-多项式乘法"><a href="#1-1-2-多项式乘法" class="headerlink" title="1.1.2 多项式乘法"></a>1.1.2 多项式乘法</h4><p>已知两个多项式 $A(x)$ 和 $B(x)$，分别是 $n$ 次多项式和 m 次多项式。</p>
<script type="math/tex; mode=display">
\begin{align}
A(x)=\sum^{n}_{i=0}a_ix^i\\
B(x)=\sum^{m}_{i=0}b_ix^i
\end{align}</script><p>公式（2）和公式（3）相乘得到一个最高为 $n+m$ 次的多项式 $C(x)$。系数向量：$\mathbf{c}=[c_0  ,c_1,\ldots,c_{m+n}]$。</p>
<script type="math/tex; mode=display">
\begin{align}
C(x)=\sum^{n+m}_{i=0}c_ix^i

\end{align}</script><h5 id="系数乘法："><a href="#系数乘法：" class="headerlink" title="系数乘法："></a>系数乘法：</h5><p>系数乘法，将两个多项式的系数相乘，系数相乘，如公式（5）所示。不难看出时间复杂为 $O(n^2)$。整理可得公式（6）。</p>
<script type="math/tex; mode=display">
\begin{align}
C_{i+j}=  \sum_{i=0}^{n} \sum_{j=0}^{m} a_i b_j 
\end{align}</script><script type="math/tex; mode=display">
\begin{align}
C_i=\sum^{i}_{j=0}a_jb_{i-j}
\end{align}</script><h5 id="点值乘法："><a href="#点值乘法：" class="headerlink" title="点值乘法："></a>点值乘法：</h5><p>点值乘法只需将要将对应的纵坐标相乘即可，但是因为新得到的多项式次数更高，所以每个因子多项式都需要提供 $m+n+1$ 个点参与运算。时间复杂度为 $O(n)$。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在计算多项式乘法时，点值表示的时间复杂度低。但是在计算系统中系数表示更加的常用。于是很自然的想到，在进行乘法时从系数表示转换到点值表示，使用点值表示法进行乘法运算，然后再转换为系数表示法。</p>
<p>但是很不幸的是，从系数表示转换到点值表示，以及点值表示到系数表示，这两个过程的时间复杂度均为 $O(n^2)$。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402191953350.svg" alt="图1 多项式乘法总结图" title="图1 多项式乘法总结图"></p>
<h4 id="1-1-3-转换优化"><a href="#1-1-3-转换优化" class="headerlink" title="1.1.3 转换优化"></a>1.1.3 转换优化</h4><p>如果通过减少求值的点数可以较少计算时间。根据函数的奇偶性我们可以只求一半的点值，从而减少一半的计算量。这里为了方便表示设一个 $n-1$ 次的一般多项式，$n=2^a , a\in \mathbb{N}$。</p>
<script type="math/tex; mode=display">
P(x)=p_0+p_1x^1+p_2x^2+\ldots +p_{n-1}x^{n-1}=\sum^{n-1}_{i=0}p_ix^i</script><p>将偶次项和奇数项分别组合：</p>
<script type="math/tex; mode=display">
P(x)=(p_0+p_2x^2\ldots+p_{n-2}x^{n-2})+(p_1x^1+\ldots +p_{n-1}x^{n-1})</script><p>对奇次项提取公因式 $x$:</p>
<script type="math/tex; mode=display">
P(x)=(p_0+p_2x^2\ldots+p_{n-2}x^{n-2})+x(p_1x^0+\ldots +p_{n-1}x^{n-2})</script><p>化简为：</p>
<script type="math/tex; mode=display">
\begin{align}
P(x)=P_e(x^2)+xP_o(x^2)
\end{align}</script><p>则我们可以取 $\frac{n}{2}$ 对相反数点，这样我们只需要计算一半的点值。</p>
<script type="math/tex; mode=display">
P(x_i)=P_e(x_i^2)+xP_o(x_i^2) \\
P(-x_i)=P_e(x_i^2)-x_iP_o(x_i^2)</script><p>  观察公式（7）不难发现，是将是将 $P(x)$ 拆成了两个规模为 $\frac{n}{2}$ 的 $P_e(x)$,$P_o(x）$。自然而然想到了递归执行。但是问题是相反数平方运算后所得结果均为正数，无法构造相反数对，无法实现递归。如果能一直保持相反数点对，那么时间复杂度可以表示为$T(n)=T(2n)+O(n)$ ，即时间复杂度为 $O(n\log n)$。</p>
<h4 id="1-1-4-单位根（复平面）"><a href="#1-1-4-单位根（复平面）" class="headerlink" title="1.1.4 单位根（复平面）"></a>1.1.4 单位根（复平面）</h4><p>既然实数域没有办法解决上面的问题，可以将起扩展到复平面。我们希望取一些点使其平方后的结果依然存在相反数对。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402191953363.svg" alt="图2 复平面图" title="图2 复平面图"></p>
<p>既然点是我们自己选的，那不如使最后一组相反数点对为 $\{1,-1\}$。我们取 n 等于 8 作为演示。不难看出最后选取的 8 个点均是 $x^8=1$ 的解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402191953795.svg" alt="图3 n=8选点示例图" title="图3 n=8选点示例图"></p>
<p>对于任意 $n=2^a , a\in \mathbb{N}$，来说即为 $x^n=1$。</p>
<p>由欧拉公式:</p>
<script type="math/tex; mode=display">
e^{i \theta}=\cos\theta+i\sin\theta</script><p>可以得到公式：</p>
<script type="math/tex; mode=display">
z^n=1=\cos2k\pi+i\sin2k\pi=e^{2k\pi i},k \in[ 0,n)</script><p>所以:</p>
<script type="math/tex; mode=display">
z=\sqrt[n]{e^{2k\pi i}}=e^\frac{2k\pi i}{n} ,k \in[ 0,n)</script><p>上面是 $n$ 次单位复数根的推导。当 $k=1$ 时，值 $\omega_n=e^\frac{2\pi i}{n}$ 被成为主 $n$ 次单位复数根，其他的 $n$ 次单位根都是 $\omega_n$ 的幂次。其中 $\theta$ 表示为复平面单位圆上的弧长。因此 $e^\frac{2\pi i}{n}$ 表示将一个单位圆均分 $n$ 份。$n=8$ 时如下图所示。​<img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402192044572.webp" alt="图4  8次单位根示意图" title="图4  8次单位根示意图">​</p>
<h5 id="n-次单位根的性质："><a href="#n-次单位根的性质：" class="headerlink" title="$n$ 次单位根的性质："></a>$n$ 次单位根的性质：</h5><p><strong>消去引理：</strong></p>
<script type="math/tex; mode=display">
\omega_{dn}^{dk}=\omega_n^k\\
\omega_{n}^{\frac{n}{2}}=-\omega_2=-1\\
\omega_{n}^{k+\frac{n}{2}}=-\omega_n^k</script><p><strong>折半引理：</strong></p>
<script type="math/tex; mode=display">
(\omega_n^k)^2=\omega_{\frac{n}{2}}^k</script><p><strong>求和引理：</strong></p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1} (\omega_n^k)^i =
\begin{cases}
0, & k \neq mn, \ m \in \mathbb{Z} \\
n, & k = mn, \ m \in \mathbb{Z}
\end{cases}</script><h3 id="1-2-DFT-与-IDFT"><a href="#1-2-DFT-与-IDFT" class="headerlink" title="1.2 $DFT$ 与 $IDFT$"></a>1.2 $DFT$ 与 $IDFT$</h3><p>经过 1.1 节的介绍已经对多项式乘法的相关内容有了相应的了解，下面开始正式介绍 $DFT$ 与 $IDFT$，将在 1.3 节介绍 $FFT$ 与 $IFFT$ 的相关内容。我们是从多项式乘法引入的$DFT$和$IDFT$，但是$DFT$和$IDFT$的应用的场景有很多，多项式求值、大数乘法，拉格朗日插值、矩阵乘法、中国剩余定理以及环同态。</p>
<h4 id="1-2-1-离散傅里叶变换（-DFT-）"><a href="#1-2-1-离散傅里叶变换（-DFT-）" class="headerlink" title="1.2.1 离散傅里叶变换（$DFT$）"></a>1.2.1 离散傅里叶变换（$DFT$）</h4><p>设有一个 $n-1$ 次的多项式 $P(x)$:</p>
<script type="math/tex; mode=display">
P(x) = a_0 + a_1x + a_2x^2 + \ldots + a_{n-1}x^{n-1}</script><p>多项式 $P(x)$ 的 $DFT$ 在单位根 $\omega_n^k = e^{2\pi i k / n}  $ 上的值计算如下：</p>
<script type="math/tex; mode=display">
P_k = P(\omega_n^k) = \sum_{j=0}^{n-1} a_j \omega_n^{kj} \quad  k = 0, 1, \ldots, n-1</script><h4 id="1-2-2-逆离散傅里叶变换（-IDFT-）"><a href="#1-2-2-逆离散傅里叶变换（-IDFT-）" class="headerlink" title="1.2.2 逆离散傅里叶变换（$IDFT$）"></a>1.2.2 逆离散傅里叶变换（$IDFT$）</h4><p>对 $DFT$ 过程我们可以通过矩阵进行描述 $y=Wa$：</p>
<script type="math/tex; mode=display">
\left[ \begin{array}{c}
y_0 \\
y_1 \\
y_2 \\
\vdots \\
y_{n-1} \\
\end{array} \right]
=
\left[ \begin{array}{cccc}
1 & 1 & \ldots & 1 \\
1 & \omega_n & \ldots & \omega_n^{n-1} \\
1 & \omega_n^2 & \ldots & \omega_n^{2(n-1)} \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega_n^{n-1} & \ldots & \omega_n^{(n-1)^2}
\end{array} \right]
\left[ \begin{array}{c}
a_0 \\
a_1 \\
a_2 \\
\vdots \\
a_{n-1} \\
\end{array} \right]</script><p>其中 $V_n$ 是一个范德蒙矩阵，是一个可逆矩阵，因此 $IDFT$：$a=W^{-1}y$。</p>
<p>下面求取:$W_n^{-1}$。矩阵 $W$ 可以表示为：$W_{jk}=ω_ n^{jk}$。$W_{jk}^{-1}$ 的值应该是 $W_{jk}$ 的共轭除以 $n$。由 $\omega _n$ 的性质，我们知道 $\omega _n^k$ 的共轭是 $\omega _n^{-k}$。因此 $W_{jk}^{-1}=\frac{1}{n}ω_ n^{-jk}$。所以 $DFT$ 和 $IDFT$ 的时间复杂一致，甚至计算流程基本一致。</p>
<script type="math/tex; mode=display">
a_j= \frac{1}{n}\sum_{j=0}^{n-1} y_j ω_ n^{-jk} \quad  k = 0, 1, \ldots, n-1</script><h3 id="1-3-快速傅里叶变化（-FFT-）"><a href="#1-3-快速傅里叶变化（-FFT-）" class="headerlink" title="1.3 快速傅里叶变化（$FFT$）"></a>1.3 快速傅里叶变化（$FFT$）</h3><p>其实 $FFT$ 的思路在 1.1.3 节中进行了介绍只是并不是很完善，下面进行一个较为细致的描述。详细介绍 FFT 的递归实现和迭代实现。</p>
<h4 id="1-3-1-FFT-递归实现"><a href="#1-3-1-FFT-递归实现" class="headerlink" title="1.3.1 $FFT$ 递归实现"></a>1.3.1 $FFT$ 递归实现</h4><p>将单位根带入公式（7）得：</p>
<script type="math/tex; mode=display">
\begin{align}
P(\omega_n^k)=P_e((\omega_n^k)^2)+{\omega_n^k}P_o((\omega_n^k)^2) \quad k \in[ 0,n)
\end{align}</script><p>根据消去引理推导出得对称性以及折半引理对公式（8）进行化简。取 $k \in[0,\frac{n}{2})$ 。</p>
<script type="math/tex; mode=display">
\begin{align*}
P(\omega_{n}^{k})&=P_{e}((\omega_{n}^{k})^2)+{\omega_{n}^{k}}P_{o}((\omega_{n}^{k})^2)\\
 & =P_{e}(\omega_{\frac{n}{2}}^{k})+{\omega_{n}^{k}}P_{o}(\omega_{\frac{n}{2}}^{k})\\ 

 \end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
P(\omega_{n}^{k+m})&=P_{e}((\omega_{n}^{k+m})^2)+\omega_{n}^{k+m}P_{o}((\omega_{n}^{k+m})^2)\\
 & =P_{e}(\omega_{\frac{n}{2}}^{k+m})+\omega_{n}^{k+m}P_{o}(\omega_{\frac{n}{2}}^{k+m})\\ 
& =P_{e}(-\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}P_{o}(-\omega_{\frac{n}{2}}^{k})\\
& =P_{e}(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}P_{o}(\omega_{\frac{n}{2}}^{k})
 \end{align*}</script><p>即公式（9-10），这两个式子也被称为 CT(Cooley-Tukey)蝶形操作，$\omega_{n}^{k}$ 被成为转换因子。</p>
<script type="math/tex; mode=display">
\begin{align}
P(\omega_{n}^{k})=P_{e}(\omega_{\frac{n}{2}}^{k})+{\omega_{n}^{k}}P_{o}(\omega_{\frac{n}{2}}^{k})\\
P(\omega_{n}^{k+m})=P_{e}(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}P_{o}(\omega_{\frac{n}{2}}^{k})
\end{align}</script><p>现在给出递归版本得算法：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Algorithm 1} & \text{ Recursion   FFT}\\ 
\hline
\textbf{Require:} & P=[p_0,p_1,\ldots,p_{n-1}]\quad n=2^{a},a\in\mathbb{N}\\ 
\textbf{function} & \text{FFT\_R}(P)\\ 

&n\leftarrow len(P)\\
&\text{if}\quad n==1 \\
&\quad \text{return}\quad P\\
&\text{endif}\\
&\omega_n \leftarrow e^{\frac{2\pi i}{n}}\\
&P_e\leftarrow [p_0,p_2,\ldots,p_{n-2}]\\
&P_o\leftarrow [p_1,p_3,\ldots,p_{n-1}]\\
&y_e\leftarrow  FFT\_R(P_e)\\
&y_o\leftarrow  FFT\_R(P_o)\\
& \text{for} \quad k \quad \text{to} \quad \frac{n}{2}-1\\
&\quad y[k]=y_e[k]+\omega_n^ky_o[k]\\
&\quad y[k+\frac{n}{2}]=y_e[k]-\omega_n^ky_o[k]\\
&\text{endfor}\\
&\text{return} \quad y \\
\textbf{end function} & \\ 
\hline & 
\end{array}</script><h5 id="蝶形操作："><a href="#蝶形操作：" class="headerlink" title="蝶形操作："></a>蝶形操作：</h5><p>蝶形操作得名于其数据流图的形状，上面的推导过程出现的是 CT 蝶形变换，还有一种 GS 蝶形变换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402192017314.svg" alt="图5 CT蝶形操作图" title="图5 CT蝶形操作图">​</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402191954300.svg" alt="图6 CT蝶形操作简化图" title="图6 CT蝶形操作简化图">​</p>
<p>通过公式（9-10）我们可以推导出 GS 蝶形变换的形式。将公式（9）和（10）分别加减运算得：</p>
<script type="math/tex; mode=display">
P(\omega_{n}^{k}) + P(\omega_{n}^{k+m}) = 2P_{e}(\omega_{\frac{n}{2}}^{k})
\\

P(\omega_{n}^{k}) - P(\omega_{n}^{k+m}) = 2\omega_{n}^{k}P_{o}(\omega_{\frac{n}{2}}^{k})</script><p>整理得公式（11-12）不难看出，GS 操作是 CT 操作的逆过程，可以用于 $IFFT$ 中,当然也可以用在$FFT$中，通常CT方法也叫$DIT$（时域抽取）操作，GS操作也叫$DIF$（频域抽取）操作。</p>
<script type="math/tex; mode=display">
\begin{align}

P_e(\omega_{\frac{n}{2}}^{k}) &= \frac{1}{2}(P(\omega_{n}^{k}) + P(\omega_{n}^{k+m})) \\
P_o(\omega_{\frac{n}{2}}^{k}) &= \frac{1}{2\omega_{n}^{k}}(P(\omega_{n}^{k}) - P(\omega_{n}^{k+m})) 

\end{align}</script><p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402191954666.svg" alt="资源 11" title="图7 GS蝶形操作">​</p>
<h4 id="1-3-2-FFT-迭代实现"><a href="#1-3-2-FFT-迭代实现" class="headerlink" title="1.3.2 $FFT$ 迭代实现"></a>1.3.2 $FFT$ 迭代实现</h4><p>继续优化。依然拿 n=8 举例。递归数据操作如图 7 所示，在递归操作中是自定向下层层展开，然后逐层向上收缩。每一次递归都会消耗堆栈资源，影响效率。如果可以从底向上计算，那么可以省去堆栈资源的消耗，提高程序运行效率。于是现在的问题就变为了如何确定递归树叶子节点的元素排序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402191954478.svg" alt="图8 n=8时递归示意图" title="图8 n=8时递归示意图">​</p>
<h5 id="位逆序"><a href="#位逆序" class="headerlink" title="位逆序"></a><strong>位逆序</strong></h5><p>将叶子节点元素顺序和原始元素顺序均使用二进制表示。发现二进制表示发生了左右对称反转，称之为位逆序变换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位逆序</span></span><br><span class="line">Layer <span class="number">4</span>:	<span class="number">0</span>	<span class="number">4</span>	<span class="number">2</span>	<span class="number">6</span>	<span class="number">1</span>	<span class="number">5</span>	<span class="number">3</span>	<span class="number">7</span></span><br><span class="line">Binary:		<span class="number">000</span> <span class="number">100</span> <span class="number">010</span> <span class="number">110</span> <span class="number">001</span> <span class="number">101</span> <span class="number">011</span> <span class="number">111</span></span><br><span class="line">Reverse:	<span class="number">000</span> <span class="number">001</span> <span class="number">010</span> <span class="number">011</span> <span class="number">100</span> <span class="number">101</span> <span class="number">110</span> <span class="number">111</span></span><br><span class="line">Decimal:	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>下面是 Bit-Reverse-Copy 的实现:</p>
<script type="math/tex; mode=display">
\begin{array}{ll}\hline\textbf{Algorithm 2} & \text{Bit-Reverse-Copy}\\ 
\hline\textbf{Require:} & A\\ \textbf{function} & \text{BitReverseCopy}(A)\\  & n\leftarrow len(A)\\  & b\leftarrow\log_2(n)\\  & \text{for}\quad i=0\quad\text{to}\quad n-1\\  & \quad r\leftarrow\text{ReverseBits}(i,b)\\  & \quad B[r]\leftarrow A[i]\\  & \text{endfor}\\  & \text{return}\quad B\\ \textbf{end function} \\ \hline \end{array}</script><p>函数 ReverseBits 的实现如下,基本过程就是取原值低位赋值给目标值低位，然后原值右移一位，目标值左移一位，直到循环结束。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Function} & \text{ReverseBits}(i, b) \\
\hline
& result \leftarrow 0 \\
& \text{for}\quad j = 0\quad\text{to}\quad b - 1 \\
& \quad result \leftarrow result \ll 1 \\
& \quad bit \leftarrow (i \gg j) \& 1 \\
& \quad result \leftarrow result \, | \, bit \\
& \text{endfor} \\
& \text{return}\quad result \\
\hline
\end{array}</script><h5 id="迭代算法实现"><a href="#迭代算法实现" class="headerlink" title="迭代算法实现"></a>迭代算法实现</h5><p>算法 3 是$DIT$实现，算法4是$DIF$实现。$s $ 可以看作是合并轮数。$m$ 是当前合并次数下每个单元的规模。其中$\hat{1}$是乘法单位元都是$\omega_n^0$。这里的$\omega_n=﻿e^{\pm2\pi i  / n}$,在进行$FFT$操作时取正，$IFFT$操作时取负。当然IFFT还需要乘上$n^{-1}$。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}\hline\textbf{Algorithm 3} & \text{DIT}\\ 
\hline
\textbf{Require:} & A=[a_0,a_1,\ldots,a_{n-1}]\quad n=2^{x},x\in\mathbb{N}\\ \textbf{function} & \text{DIT}(A)\\  
& n\leftarrow len(A)\\  
& P\leftarrow BitReverseCopy(A)\\
& \text{for}\quad s=1\quad\text{to}\quad \log_2n\\  
& \quad m=2^s\\
& \quad \omega_m=\omega_n^{\frac{n}{m}}\\

& \quad\text{for}\quad k=0\quad \text{to} \quad n-1 \quad \text{by}\quad m\\  
& \quad\quad \varphi=\hat{1}\\

& \quad\quad\text{for}\quad j=0\quad\text{to} \quad \frac{m}{2}-1\\  
& \quad\quad\quad t=\varphi P[k+j+\frac{m}{2}]\\
& \quad\quad\quad u= P[k+j]\\
& \quad\quad\quad P[k+j]= u+t\\
& \quad\quad\quad P[k+j+\frac{m}{2}]= u-t\\
& \quad\quad\quad \varphi=\varphi \omega_m\\
& \quad\quad\text{endfor}\\ 

& \quad\text{endfor}\\ 

& \text{endfor}\\  
& \text{return}\quad P\\
 \textbf{end function}
& \\ 
\hline 
& \end{array}</script><script type="math/tex; mode=display">
\begin{array}{ll}\hline\textbf{Algorithm 4} & \text{DIF}\\ 
\hline
\textbf{Require:} & A=[a_0,a_1,\ldots,a_{n-1}]\quad n=2^{x},x\in\mathbb{N}\\ \textbf{function} & \text{DIF}(P)\\  
& n\leftarrow len(A)\\  
& P\leftarrow A\\
& \text{for}\quad s=\log_2n \quad\text{to}\quad 1\\  
& \quad m=2^s\\
& \quad \omega_m=\omega_n^{\frac{n}{m}}\\

& \quad\text{for}\quad k=0\quad \text{to} \quad n-1 \quad \text{by}\quad m\\  
& \quad\quad \varphi=\hat{1}\\

& \quad\quad\text{for}\quad j=0\quad\text{to} \quad \frac{m}{2}-1\\  
& \quad\quad\quad t= P[k+j+\frac{m}{2}]\\
& \quad\quad\quad u= P[k+j]\\
& \quad\quad\quad P[k+j]= u+t\\
& \quad\quad\quad P[k+j+\frac{m}{2}]= \varphi(u-t)\\
& \quad\quad\quad \varphi=\varphi \omega_m\\
& \quad\quad\text{endfor}\\ 

& \quad\text{endfor}\\ 

& \text{endfor}\\  
& P\leftarrow BitReverseCopy(P)\\
& \text{return}\quad P\\
 \textbf{end function}
& \\ 
\hline 
& \end{array}</script><p>下面是 n=8 时，$DIT$迭代 $FFT$ 的数据流图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402291729252.svg" alt="图9 n=8迭代DIT数据流图" title="图9 n=8迭代DIT数据流图">​</p>
<h5 id="迭代的另一种视角"><a href="#迭代的另一种视角" class="headerlink" title="迭代的另一种视角"></a>迭代的另一种视角</h5><p>如果不对输入进行位逆序而是对输出进行位逆序应当怎样计算，下面给出一个示例算法，该算法和算法3的逻辑是类似的。只是出现了些许变动。这里的$\Phi_{rev}$是位逆序后的$\omega$的幂次表，需要注意的是这里不对输入进行位逆序而是对单位根幂次表进行位逆序。由于上述的变换，数据流图也发生了相应的改变。m表示的是当前轮次NTT的大小，n表示当前轮次CT跨度，$j_1$表示分组的起点，数据流图如图10所示，输出结果是位逆序后的。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}\hline\textbf{Algorithm 5} & \text{DIT root}\\ 
\hline
\textbf{Require:} & A=[a_0,a_1,\ldots,a_{n-1}]\quad n=2^{x},x\in\mathbb{N} \quad \Phi_{rev} \\ 
\textbf{function} & \text{DIT}(A)\\  
& t=n\\ 
& \text{for}\quad m=1\quad\text{to}\quad n \quad\text{by}\quad m\\  
& \quad t=\frac{t}{2}\\
& \quad\text{for}\quad i=0\quad \text{to} \quad m-1 \\  
& \quad\quad j =2\cdot i\cdot t\\
& \quad\quad \varphi =\Phi_{rev}[m+i]\\
& \quad\quad\text{for}\quad k=0\quad\text{to} \quad t\\  
& \quad\quad\quad v=\varphi P[k+j+t]\\
& \quad\quad\quad u= P[k+j]\\
& \quad\quad\quad P[k+j]= u+v\\
& \quad\quad\quad P[k+j+t]= u-v\\
& \quad\quad\text{endfor}\\ 

& \quad\text{endfor}\\ 

& \text{endfor}\\  
& \text{return}\quad P\\
 \textbf{end function}
& \\ 
\hline 
& \end{array}</script><p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202407121417909.svg" alt="图10 n=8迭代DIT数据流图2" title="图10 n=8迭代DIT数据流图2">​</p>
<h3 id="1-4-快速数论变换（-NTT-）"><a href="#1-4-快速数论变换（-NTT-）" class="headerlink" title="1.4 快速数论变换（$NTT$）"></a>1.4 快速数论变换（$NTT$）</h3><p>$FFT$ 存一些问题。首先 FFT 是在复数域上的表示，而计算机系统中表示复数，需要比实数花费更多的资源，且复数运算也比实数运算更加复杂。此外 FFT 涉及大量的正余弦运算，对于精度有影响。于是我们期望在实数域内寻找类似单位根性质的数学概念。有限域上的原根满足相应的要求。</p>
<h4 id="1-4-1-数学基础"><a href="#1-4-1-数学基础" class="headerlink" title="1.4.1 数学基础"></a>1.4.1 数学基础</h4><h5 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h5><p>欧拉函数，即 $\varphi(n)$,表示的是小于等于 $n$ 且和 $n$ 互素的数的个数。当 n 是素数时 $\varphi(n)=n-1$。</p>
<h5 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h5><p>对于 $a \in \mathbb{Z}$ ,$m\in \mathbb{N}^*$,若 $\gcd(a,m)=1$,则 $a^{\varphi(m)} \equiv 1 \pmod{m}$。</p>
<h5 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h5><p>若 $p $ 为素数，$\gcd(a,p)=1$,则 $a^{p-1} \equiv 1 \pmod{p}$。</p>
<p>也可表达为，对于任意整数 $a $，有 $a^p \equiv a \pmod{p}$。</p>
<p>利用费马小定理求逆元:$a^{-1}=a^{p-2}$</p>
<h5 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h5><p>由欧拉定理可知，若 $\gcd(a,p)=1$，一定存在一个最小的正整数 $n$ 满足同余式 $a^n \equiv 1 \pmod{m}$。这个 $n$ 被称作 $a$ 模 $m$ 的阶记作 $\delta_m(a) $ 或者 $ord_m(a)$。具有以下性质：</p>
<p>性质 1：$a,a^2,\ldots,a^{\delta_m(a)}$ 模 $m $ 两两不同余，之后进入周期。</p>
<p>性质 2：若 $a^n \equiv 1 \pmod{m}$,则 $\delta_m(a)|n$。可以推导出若 $a^p \equiv a^q \pmod{m} $，则有 $p \equiv q \pmod{\delta_m(a)}$。</p>
<h5 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h5><p>给定  $n \in \mathbb{N}^*$ ，$g \in \mathbb{Z}$，满足  $\gcd(g, m) = 1$，且  $\delta_m(g) = \varphi(m)$ ，则称  $g$  为模 $m$ 的原根。</p>
<p>即 $g$ 满足 $\delta_m(g)=| \mathbb{Z}_m^* |=\varphi(m)$ 。当 $m$ 是素数时，我们有 $g^i \mod m$，$0&lt;i&lt;m$ 的结果互不相同</p>
<p>原根个数：若一个数 $m$ 有原根，则它原根的个数为 $\varphi(\varphi(m))$。</p>
<p>原根存在定理：一个数 $m$ 存在原根当且仅当 $m=2,4,p^a,2p^a$ ，其中 $p$ 为奇素数，$a\in \mathbb{N}^*$。</p>
<h5 id="原根的性质"><a href="#原根的性质" class="headerlink" title="原根的性质"></a>原根的性质</h5><p>原根具有以下性质，不难看与单位根具有类似的性质。所以可以用于替代单位根，用于简化 $DFT$ 计算。</p>
<p>不重性：$\forall 0 \leq i &lt; j &lt; \varphi(p),\ g^i \not\equiv g^j \pmod{p} $</p>
<p>折半性：定义 $g_n = g^{\frac{\delta_p(g)}{n}} \equiv g^{\frac{p-1}{n}}$,$g_n^k = (g_n)^k$ 则 $g_{an}^{ak} \equiv g_n^k \pmod{p}$。</p>
<p>对称性：$g_{2n}^{k+n} \equiv - g_{2n}^k \pmod{p}$</p>
<p>求和性：$\sum_{i=0}^{n-1} (g_n)^{ki} \equiv n[k=0] \pmod{p} $，$k=0$ 为真 $[k=0]=1$,否则为 $0$。</p>
<h5 id="原根与模数的选择"><a href="#原根与模数的选择" class="headerlink" title="原根与模数的选择"></a>原根与模数的选择</h5><p>为了实现多次二分，模数 $p$ 应选可以拆分为 $q\times 2^k +1$ 的素数,$q$ 为奇素数，$k$ 为整数,$2^k$ 模数的阶，也就是原根的最大数量。可以看下表的例子。</p>
<script type="math/tex; mode=display">
\text{表 1：原根和模数的相关数据}\\ \begin{array}{cccc} \hline \text{原根 } g & \text{模数 } p & \text{分解 } p & \text{模数的阶} \\ \hline 3 & 469762049 & 7 \times 2^{26} + 1 & 2^{26} \\ 3 & 998244353 & 119 \times 2^{23} + 1 & 2^{23} \\ 3 & 2281701377 & 17 \times 2^{27} + 1 & 2^{27} \\ \hline \end{array}</script><h4 id="1-4-2-NTT-的递归实现"><a href="#1-4-2-NTT-的递归实现" class="headerlink" title="1.4.2 $NTT$ 的递归实现"></a>1.4.2 $NTT$ 的递归实现</h4><p>将原根带入公式（7）得：</p>
<script type="math/tex; mode=display">
\begin{align}
P(g_n^k)=P_e((g_n^k)^2)+{g_n^k}P_o((g_n^k)^2)\mod p \quad k \in[ 0,n)
\end{align}</script><p>根据消去引理推导出得对称性以及折半引理对公式（13）进行化简。取 $k \in[0,\frac{n}{2})$ 。</p>
<script type="math/tex; mode=display">
\begin{align*}
P(g_{n}^{k})&=P_{e}((g_{n}^{k})^2)+{g_{n}^{k}}P_{o}((g_{n}^{k})^2) \mod p\\
 & =P_{e}(g_{\frac{n}{2}}^{k})+{g_{n}^{k}}P_{o}(g_{\frac{n}{2}}^{k}) \mod p\\ 

 \end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
P(g_{n}^{k+m})&=P_{e}((g_{n}^{k+m})^2)+g_{n}^{k+m}P_{o}((g_{n}^{k+m})^2) \mod p\\
 & =P_{e}(g_{\frac{n}{2}}^{k+m})+g_{n}^{k+m}P_{o}(g_{\frac{n}{2}}^{k+m}) \mod p\\ 
& =P_{e}(-g_{\frac{n}{2}}^{k})-g_{n}^{k}P_{o}(-g_{\frac{n}{2}}^{k}) \mod p\\
& =P_{e}(g_{\frac{n}{2}}^{k})-g_{n}^{k}P_{o}(g_{\frac{n}{2}}^{k}) \mod p
 \end{align*}</script><p>简化为：</p>
<script type="math/tex; mode=display">
P(g_{n}^{k})=P_{e}(g_{\frac{n}{2}}^{k})+{g_{n}^{k}}P_{o}(g_{\frac{n}{2}}^{k})\\
P(g_{n}^{k+m})=P_{e}(g_{\frac{n}{2}}^{k})-g_{n}^{k}P_{o}(g_{\frac{n}{2}}^{k})</script><p>现在给出递归版本得算法,不难发现除了将单位根替换为原根，增加模运算，以及增加了参数 ，原根 $g$，模数 $p $ 外与 $FFT$ 并无太大区别。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Algorithm 6} & \text{ Recursion Number Theoretic Transform (NTT)}\\ 
\hline
\textbf{Require:} & A=[a_0,a_1,\ldots,a_{n-1}],\quad n=2^{k},\quad g ,\quad p \\
\textbf{function} & \text{NTT\_R}(A, g, p)\\ 

&n\leftarrow \text{len}(A)\\
&\text{if}\quad n==1 \\
&\quad \text{return}\quad A\\
&\text{endif}\\
&g_n \leftarrow g^{\frac{p-1}{n}} \pmod p\\
&A_e\leftarrow [a_0,a_2,\ldots,a_{n-2}]\\
&A_o\leftarrow [a_1,a_3,\ldots,a_{n-1}]\\
&Y_e\leftarrow  \text{NTT\_R}(A_e, g_n^2, p)\\
&Y_o\leftarrow  \text{NTT\_R}(A_o, g_n^2, p)\\
& \text{for} \quad k \quad \text{from} \quad 0 \quad \text{to} \quad n/2-1\\
&\quad Y[k]= (Y_e[k] + g_n^k Y_o[k]) \pmod p\\
&\quad Y[k+n/2]= (Y_e[k] - g_n^k Y_o[k]) \pmod p\\
&\text{end for}\\
&\text{return} \quad Y \\
\textbf{end function} & \\ 
\hline & 
\end{array}</script><blockquote>
<p>注意NTT里的$g^{-1}$是取逆元操作，在计算$INTT$时请注意。</p>
</blockquote>
<h4 id="1-4-3-NTT-的迭代实现"><a href="#1-4-3-NTT-的迭代实现" class="headerlink" title="1.4.3 $NTT$ 的迭代实现"></a>1.4.3 $NTT$ 的迭代实现</h4><p>$NTT$ 的迭代实现同理，因此不再赘述，直接给出相应的算法。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Algorithm 7} & \text{Iteration NTT}\\ 
\hline
\textbf{Require:} & A=[a_0,a_1,\ldots,a_{n-1}],\ n=2^{k},\quad  g_n, \quad p\\ 
\textbf{function} & \text{NTT\_I}(A, g_n, p)\\  
& n \leftarrow \text{len}(A)\\  
& P \leftarrow \text{BitReverseCopy}(A)\\
& \text{for}\ s=1\ \text{to}\ \log{n}\\  
& \quad m=2^s\\
& \quad g_m=g_n^{\frac{n}{m}} \pmod p\\
& \quad \text{for}\ k=0\ \text{to}\ n-1\ \text{by}\ m\\  
& \quad\quad \varphi=\hat{1}\\
& \quad\quad \text{for}\ j=0\ \text{to}\ \frac{m}{2}-1\\  
& \quad\quad\quad t=\varphi P[k+j+\frac{m}{2}] \pmod p\\
& \quad\quad\quad u= P[k+j] \pmod p\\
& \quad\quad\quad P[k+j]= (u+t) \pmod p\\
& \quad\quad\quad P[k+j+\frac{m}{2}]= (u-t) \pmod p\\
& \quad\quad\quad \varphi=(\varphi \cdot g_m) \pmod p\\
& \quad\quad \text{endfor}\\ 
& \quad \text{endfor}\\ 
& \text{endfor}\\  
& \text{return}\ P\\
\textbf{end function} & \\ 
\hline
& 
\end{array}</script><h3 id="1-5-矩阵DFT​算法"><a href="#1-5-矩阵DFT​算法" class="headerlink" title="1.5  矩阵DFT​算法"></a>1.5  矩阵DFT​算法</h3><p>现在介绍另外一种算法，这种算法提高缓存命中率，从而提高执行效率。这种算法是将输入看作是一个行优先的矩阵进行计算，请注意对于NTT来说实际的输入指的是系数$a_i$。</p>
<p>如果 $n=R\cdot C$ 我们可以用 $i_r\in[0,R)$ 和 $i_c \in [0,C)$ 重写$i=i_r\cdot C+i_c$ 。这将创建一个对应 $[0,n) \backsimeq[0,R) \times[0,C)$。另一种对应关系是 $k=k_r+k_c\cdot R$ ,注意这里输出的顺序已经变成了列优先了。将$i$和$k$带入下式。</p>
<script type="math/tex; mode=display">
P_{k}=P(\omega_{n}^{k})=\sum_{i=0}^{n-1}a_{i}\omega_{n}^{ki}\quad k=0,1,\ldots,n-1</script><p>需要提前明确的一点是这里公式中$\omega$既可以是原根又可以是单位根,不过为了统一表示省去了原根的取模操作。替换可得：</p>
<script type="math/tex; mode=display">
\begin{align}P_{k_{r}+k_{c}\cdot R}=\sum_{i_{c}=0}^{C-1}\sum_{i_{r}=0}^{R-1}a_{i_{r}\cdot C+i_{c}}\cdot\omega_{R\cdot C}^{(k_{r}+k_{c}\cdot R)(i_{r}\cdot C+i_{c})}\end{align}</script><p>将$\omega$的幂次展开：</p>
<script type="math/tex; mode=display">
\begin{align*}
\omega_{R\cdot C}^{(k_{r}+k_{c}\cdot R)(i_{r}\cdot C+i_{c})}&=\omega_{R\cdot C}^{i_{c}k_{r}+i_{c}k_{c}\cdot R+i_{r}k_{r}\cdot C+i_{r}k_{c}\cdot RC} \\&=\omega_{R\cdot C}^{i_{c}k_{r}}\cdot \omega_{R\cdot C}^{i_{c}k_{c}\cdot R}\cdot \omega_{R\cdot C}^{i_{r}k_{r}\cdot C}\cdot \omega_{R\cdot C}^{i_{r}k_{c}\cdot RC}
\end{align*}</script><p>根据原根的折半性质或者单位根的消去引理$\omega_{an}^{ak}=\omega_n^k$，可得：</p>
<script type="math/tex; mode=display">
\omega_{R\cdot C}^{i_{c}k_{r}}\cdot \omega_{R\cdot C}^{i_{c}k_{c}\cdot R}\cdot \omega_{R\cdot C}^{i_{r}k_{r}\cdot C}\cdot \omega_{R\cdot C}^{i_{r}k_{c}\cdot RC}=\omega_{n}^{i_{c}k_{r}}\cdot \omega_{C}^{i_{c}k_{c}}\cdot \omega_{R}^{i_{r}k_{r}}\cdot1</script><p>则公式(14)变为如下形式：</p>
<script type="math/tex; mode=display">
P_{k_{r}+k_{c}\cdot R}=\sum_{i_{c}=0}^{C-1}\sum_{i_{r}=0}^{R-1}a_{i_{r}\cdot C+i_{c}}\cdot \omega_{n}^{i_{c}k_{r}}\cdot \omega_{C}^{i_{c}k_{c}}\cdot \omega_{R}^{i_{r}k_{r}}</script><p>添加一些括号来确定运算顺序则变成了：</p>
<script type="math/tex; mode=display">
P_{k_{r}+k_{c}\cdot R}=\sum_{i_{c}=0}^{C-1}\Bigg[\bigg(\sum_{i_{r}=0}^{R-1}a_{i_{r}\cdot C+i_{c}}\cdot \omega_{R}^{i_{r}k_{r}}\bigg)\omega_{n}^{i_{c}k_{r}} \Bigg] \omega_{C}^{i_{c}k_{c}}</script><p>首先对输入a子序列进行长度为$R$的$DFT$操作，然后对结果乘上旋转因子，最后进行长度为$C$的$DFT$操作。这么看可能不直观，我们将输入写成一个$R \times C$大小的矩阵：</p>
<script type="math/tex; mode=display">
a
=
\left[ \begin{array}{ccccc}
a_0 & a_1 & a_2 &\ldots & a_{C-1} \\
a_C & a_{C+1} & a_{C+2} & \ldots & a_{C+(C-1)} \\
a_{2C} & a_{2C+1} & a_{2C+2} & \ldots & a_{2C+(C-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
a_{(R-1)C} & a_{(R-1)C+1} & a_{(R-1)C+2}& \ldots & a_{(R-1)C+(C-1)}
\end{array} \right]</script><p>先对对所有列进行DFT运算，然后所有元素乘上相应的转换因子，最后对所有行进行DFT运算。下面是转换转换因子矩阵$T$，注意转换因子矩阵与对列进行DFT的结果进行的是逐点相乘。因为输出是列优先排序，所以需要对结果进行一个转置，从而使得输入与输出保持同一顺序。</p>
<script type="math/tex; mode=display">
T=\left[\begin{array}{ccccc}
1 & 1 & 1 & \ldots & 1\\
1 & \omega &\omega^2 & \ldots & \omega^{C-1}\\
1 & \omega ^2 & \omega ^4 &\ldots & \omega^{2(C-1)}\\
\vdots & \vdots& \vdots & \ddots & \vdots\\ 
1 & \omega^{R-1}&\omega^{2(R-1)} & \ldots & \omega^{(C-1)(R-1)}
\end{array}\right]</script><h5 id="Four-step-DFT"><a href="#Four-step-DFT" class="headerlink" title="Four-step DFT"></a>Four-step DFT</h5><p>对上面的算法进行一个总结就是所谓的四步DFT算法,$[R \times C]$，表示为大小为$R\times C$的行优先矩阵。</p>
<blockquote>
<p>$IDFT*$是省略乘上$n^{-1}$的$IDFT$，所以最后需要补上$n^{-1}$。</p>
</blockquote>
<p><strong>DFT:</strong></p>
<ol>
<li>$[R \times C]$,对每一列进行长度为$R$的$DFT$运算。</li>
<li>$[R \times C]$,所有元素乘上对应的转换因子$\omega^{ik}$。</li>
<li>$[R \times C]$,对每一行进行长度为$C$的$DFT$运算。</li>
<li>$[R \times C]$,将矩阵进行转置。</li>
</ol>
<p><strong>IDFT*：</strong></p>
<ol>
<li>$[C \times R]$,将矩阵进行转置。</li>
<li>$[R \times C]$,对每一行进行长度为$C$的$IDFT*$运算。</li>
<li>$[R \times C]$,所有元素乘上对应的转换因子$\omega^{-ik}$。</li>
<li>$[R \times C]$,对每一列进行长度为$R$的$IDFT*$运算。</li>
</ol>
<h5 id="Six-step-DFT"><a href="#Six-step-DFT" class="headerlink" title="Six-step DFT"></a>Six-step DFT</h5><p>对列进行操作，无法读取连续的内存会影响计算效率，可以增加转置操作，于是获得六步DFT算法：</p>
<p><strong>DFT:</strong></p>
<ol>
<li>$[R \times C]$,将矩阵进行转置。</li>
<li>$[C \times R]$,对每一行进行长度为$R$的$DFT$运算。</li>
<li>$[C \times R]$,将矩阵进行转置。</li>
<li>$[R \times C]$,所有元素乘上对应的转换因子$\omega^{ik}$。</li>
<li>$[R \times C]$,对每一行进行长度为$C$的$DFT$运算。</li>
<li>$[R \times C]$,将矩阵进行转置。</li>
</ol>
<p><strong>IDFT*:</strong></p>
<ol>
<li>$[C \times R]$,将矩阵进行转置。</li>
<li>$[R \times C]$,对每一行进行长度为$C$的$IDFT*$运算。</li>
<li>$[R \times C]$,所有元素乘上对应的转换因子$\omega^{-ik}$。</li>
<li>$[R \times C]$,将矩阵进行转置。</li>
<li>$[C \times R]$,对每一行进行长度为$R$的$IDFT*$运算。</li>
<li>$[C \times R]$,将矩阵进行转置。</li>
</ol>
<h2 id="2-NTT-设计"><a href="#2-NTT-设计" class="headerlink" title="2 NTT 设计"></a>2 NTT 设计</h2><p>本节主要是介绍对NTT的设计，例如模约简方案、转置优化以及预计算。最后探讨有哪些可以进行的优化。</p>
<h3 id="2-1-模约简"><a href="#2-1-模约简" class="headerlink" title="2.1 模约简"></a>2.1 模约简</h3><h4 id="2-1-1-朴素方案"><a href="#2-1-1-朴素方案" class="headerlink" title="2.1.1 朴素方案"></a>2.1.1 朴素方案</h4><p>在模数约简的朴素方法中，如果硬件支持的话，会使用一个硬件指令将两个字（word）长度的被除数除以一个字长度的除数，得到一个字长度的商和一个字长度的余数。如果硬件不支持这种指令，那么就需要在软件中模拟这种指令。</p>
<p>这样的指令在x86和x86-64架构中是存在的。对于软件模拟，GNU GCC和Clang编译器在32位平台上提供了uint64_t类型，在64位平台上提供了unsigned __int128类型，并且这些类型都支持除法操作。</p>
<h4 id="2-1-2-Barrett-约简"><a href="#2-1-2-Barrett-约简" class="headerlink" title="2.1.2 Barrett 约简"></a>2.1.2 Barrett 约简</h4><p>巴雷特约简的思路很简单，将计算$z =a \mod p$，转换为$z=a- tp,t=\lfloor ap^{-1}\rfloor$ 。于是问题就从模运算转换为了求取$p^{-1}$的近似值,也就是$t$的近似值。</p>
<p>对$t$进行进行变换：</p>
<script type="math/tex; mode=display">
t=\lfloor \frac{a}{p} \rfloor=\lfloor \frac{\frac{a}{b^{k-1}}\frac{b^{2k}}{p}}{b^{k+1}} \rfloor</script><p>其中$b$是基底，计算机系统中通常使用二进制表示，即$b=2$，$k$是模数相对于基底的位宽$k=\log_{b}p+1$，之所以是$b^{2k}$是因为通常运用模约简的场景是模乘，因此$a\in[0,p^2)$。经过变换，我们发现分离出来一个一个仅和模数有关的量:$\alpha = \frac{b^{2k}}{p}$，这意味着对同一模数的约简可以提前计算$\alpha$，其他部分可以通过右移和乘法完成，乘法运算效率显著高于除法运算，位移效率更快，计算速度提升了很多。</p>
<p>为了避免浮点数计算，令$\beta=\lfloor \frac{b^{2k}}{p} \rfloor$,替换掉$\alpha$,得到$t$的近似$\hat{t}$：</p>
<script type="math/tex; mode=display">
\hat{t}=\lfloor \frac{\lfloor\frac{a}{b^{k-1}}\rfloor \beta}{b^{k+1}} \rfloor=\lfloor \frac{\lfloor\frac{a}{b^{k-1}}\rfloor \lfloor \frac{b^{2k}}{p} \rfloor}{b^{k+1}} \rfloor</script><p>现在考虑$t$与$\hat{t}$的误差：</p>
<script type="math/tex; mode=display">
\lambda = \frac{a}{b^{k-1}} - \lfloor \frac{a}{b^{k-1}} \rfloor</script><script type="math/tex; mode=display">
\mu = \frac{b^{2k}}{p} - \lfloor \frac{b^{2k}}{p} \rfloor</script><p>且$0 \le \lambda \lt 1$,$0 \le \mu \lt 1$，此外还有：</p>
<script type="math/tex; mode=display">
t=\lfloor\frac{a}{b^{k-1}}\cdot\frac{b^{2k}}{p}\cdot\frac{1}{b^{k+1}}\rfloor=\lfloor\frac{(\lfloor\frac{a}{b^{k-1}}\rfloor+\lambda)(\lfloor\frac{b^{2k}}{p}\rfloor+\mu)}{b^{k+1}}\rfloor\leq\lfloor\hat{t}+\frac{\lfloor\frac{a}{b^{k-1}}\rfloor+\lfloor\frac{b^{2k}}{p}\rfloor+1}{b^{k+1}}\rfloor</script><p>因为$a\lt b^{2k}$,所以$\lfloor \frac{a}{b^{k-1}} \rfloor \leq b^{k+1}-1$；又因为$p \ge b^{k-1}$,所以$\lfloor \frac{b^{2k}}{p}\rfloor \leq b^{k+1}$。对上面不等式放缩：</p>
<script type="math/tex; mode=display">
t\leq\lfloor\hat{t}+\frac{b^{k+1}-1+b^{k+1}+1}{b^{k+1}}\rfloor=\lfloor\hat{t}+2\rfloor</script><p>又因为$\hat{t} \le t$,所以可得：</p>
<script type="math/tex; mode=display">
t-2 \le \hat{t} \le t</script><p>近似性不错，进一步可得：</p>
<script type="math/tex; mode=display">
0 \lt a - \hat{t}p \le a - (t-2)p=a-tp+2p</script><p>又因为$a-tp=z\lt p$，所以：</p>
<script type="math/tex; mode=display">
0 \lt a - \hat{t}p \lt 3p</script><p>不难看出使用近似方法得出得值有可能比p大，但是通过最多两次减法就可以修正误差，下面给出完整的算法：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Algorithm 8} & \text{Barrett 约简}\\ 
\hline
\textbf{Require:} & a\quad \beta=\lfloor \frac{b^{2k}}{p} \rfloor\quad p\\ 
\textbf{function} & Barrett(a,\beta,p)\\  
& \hat{t} \leftarrow \lfloor \frac{\lfloor\frac{a}{b^{k-1}}\rfloor \beta}{b^{k+1}} \rfloor\\  
& z_1 \leftarrow a \mod b^{k+1}\\
& z_2 \leftarrow \hat{t}\cdot p \mod b^{k+1}\\
& z=z_1-z_2\\
& \text{if} \ z \lt 0\\  
& \quad z=z+b^{k+1}\\
& \text{endif}\\  
& \text{while} \ z \ge p\\  
& \quad z=z-p\\
& \text{endwhile}\\  
& \text{return}\ z\\
\textbf{end function} & \\ 
\hline
& 
\end{array}</script><p>$z_1$和$z_2$的运算可以通过位与操作直接去掉k位的高位即可，简化了计算。下面给出$\beta$的算法：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Algorithm 9} & \text{计算} \beta\\ 
\hline
\textbf{Require:} & p\quad k \quad b\\ 
\textbf{function} & get\beta(p,k,b)\\  
& \beta \leftarrow b^k\\  
& \text{repeat} \\  
& \quad s \leftarrow \beta \\
& \quad \beta \leftarrow 2\beta -\lfloor\frac{ p\lfloor \frac{\beta^2}{b^k} \rfloor }{b^k}   \rfloor\\
& \text{until} \ \beta \le s  \\  
& t \leftarrow b^{2k}-p\beta\\
& \text{while} \ t \lt 0\\  
& \quad \beta \leftarrow \beta -1\\ 
& \quad t \leftarrow t+p\\ 
& \text{endwhile}\\  
& \text{return}\ \beta\\
\textbf{end function}  \\
\hline
&\end{array}</script><h4 id="2-1-3-Montgomery-约简"><a href="#2-1-3-Montgomery-约简" class="headerlink" title="2.1.3  Montgomery 约简"></a>2.1.3  Montgomery 约简</h4><p>蒙哥马利模乘约减的思路是通过变换，将需要取模的数控制到很小的范围（$[0,(p-1)^2] \rightarrow [0,2p-1]$ ）然后通过少量减法获取最后结果。并通过位运算简化计算，例如：右移除法、位与取模。</p>
<h5 id="蒙哥马利约简"><a href="#蒙哥马利约简" class="headerlink" title="蒙哥马利约简"></a>蒙哥马利约简</h5><p>对于$\forall t \in \mathbb{Z}$且满足$a &lt; r p$，$r\gt p$，$\gcd(r,p)=1$ 。$p$是以$b$为基底,长度为$k$的整数，则r的取值为$b^k$，计算机中$b$为$2$，显然$r\gt p$。但是只有当$\gcd(b,p)=1$时才满足$\gcd(r,p)=1$，之前提到的格式是满足条件的。</p>
<p>由于$r$和$p$互素，所以存在$r’,p’  \in[0,p)$使得下式成立，$r’$是$r$在$p$下的逆元 ，$p’$是$p$在$r$下的负逆元。</p>
<script type="math/tex; mode=display">
rr'-pp'=1</script><p>于是：</p>
<script type="math/tex; mode=display">
\begin{align*}
ar' &=ar'\frac{r}{r} \\
&=\frac{arr'}{r} \\
&=\frac{a(1+pp')}{r}  \\
&=\frac{a+app'}{r}  \\
&=\frac{a+(\lfloor \frac{ap'}{r} \rfloor r+(ap' \bmod r))p}{r}   \\
&=\frac{a+(ap' \bmod r)p}{r}+\lfloor \frac{ap'}{r} \rfloor p   \\
&\equiv \frac{a+(ap' \bmod r)p}{r} &\pmod{p} \\
&\equiv \frac{a+((a\bmod r)p' \mod r)p}{r} &\pmod{p} \\
\end{align*}</script><p>其中$\lfloor \frac{ap’}{r} \rfloor r+(ap’ \bmod r)$是将$ap’$表达为成商乘上除数加余数的形式。上面的推导过程将对$ar’$模$p$转换为了对$\frac{a+((a\bmod r)p’ \bmod r)p}{r}$模$p$操作。显然$((a\mod r)p’ \mod r)p \lt rp$又因为$a &lt; r p$所以可得下面的关系，不难发现最多只需一次减法就可以完成取模操作，其中模$r$可以通过位与运算，除$r$可以通过位右移运算完成，之所以做两次模$r$运算是为了降低乘法位宽。</p>
<script type="math/tex; mode=display">
\frac{t+((t\mod r)p' \mod r)p}{r} \lt 2p</script><p>下面给出相应的算法：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hline
\textbf{Algorithm 10} & \text{蒙哥马利约简} \\ 
\hline
\textbf{Require:} & p\quad r \quad p' \quad (pp' \equiv-1\mod r )\quad \\ 
\textbf{function} & REDC(a)\\  
& m \leftarrow (a\bmod r)p' \bmod r \\
& t \leftarrow (a+mp) \text{div }r \\
& \text{if} \ t \gt p\\  
& \quad  \quad \text{return}\ t-p\\
& \text{else} \\  
& \quad  \quad \text{return}\ t\\
& \text{endif}\\  
\textbf{end function}  \\
\hline
&\end{array}</script><h5 id="蒙哥马利域"><a href="#蒙哥马利域" class="headerlink" title="蒙哥马利域"></a>蒙哥马利域</h5><p>由上面蒙哥马利约简的过程不难发现实际是对$xR^{-1}$(这里的$R^{-1}$就是上面提到的$r’$,只是为了方便区分)进行约简，所以在使用蒙哥马利约简时，首先需要转换到蒙哥马利域中，蒙哥马利域中的形式表示为$\bar{x}$，转换入蒙哥马利域的方式：</p>
<script type="math/tex; mode=display">
\bar{x} =x \cdot R \pmod p</script><p>显然，转入蒙哥马利域的成本是高昂的，只有在蒙哥马利域内计算值得时才会使用蒙哥马利约简，在蒙哥马利域中加法和减法（结合律）不受影响。</p>
<script type="math/tex; mode=display">
\bar{x}+\bar{y} = xR+yR=(x+y)R = \overline{x+y} \pmod p</script><p>但是蒙哥马利域上的乘法是不正确的，这里蒙哥马利域中的乘法用 $\times$表示，正常的乘法用$\cdot$表示。我们期望的结果是：</p>
<script type="math/tex; mode=display">
\bar{x}\times\bar{y}=\overline{x\cdot y}=(x\cdot y) R  \pmod{p}</script><p>但是实际上如果直接相乘获得结果如下：</p>
<script type="math/tex; mode=display">
\bar{x}\cdot\bar{y}=xR\cdot yR=(x\cdot y) RR  \pmod{p}</script><p>蒙哥马利域上的乘法定义如下：</p>
<script type="math/tex; mode=display">
\bar{x}\times\bar{y}=(\bar{x}\cdot \bar{y}) R^{-1}\mod{p} =(x\cdot y) R \mod{p}=RECD(\bar{x}\cdot \bar{y})</script><p>最后就是蒙哥马利域的转出，转出如下所示。</p>
<script type="math/tex; mode=display">
x = \bar{x}\cdot R^{-1} \mod{p}=RECD(\bar{x})</script><h5 id="蒙哥马利模乘"><a href="#蒙哥马利模乘" class="headerlink" title="蒙哥马利模乘"></a>蒙哥马利模乘</h5><p>在执行蒙哥马利乘法本身开销并不高，但是需要完成一些提前计算，这些计算的开销较高。</p>
<ul>
<li>蒙哥马利域的转入</li>
<li>$p’$的计算</li>
<li>蒙哥马利域的转出</li>
</ul>
<p>在约简过程中已经完成了蒙哥马利域的转出。p’的计算可以通过扩展欧几里得算法获得。对于转入还存在另一种策略：</p>
<script type="math/tex; mode=display">
\bar{x} =x \cdot R \mod{p} =x \times R^2  =REDC(x\cdot (R^2 \mod p))</script><p>第二种策略策略是省去模p的运算，但是失去了乘R位运算优势，取而代之的是乘上$R^2 \mod p$，可以提前计算，并需要执行约简操作，因为取模开销很大，大概率第二种策略效率更高一点。于是蒙哥马利模乘可以表示如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
z&=x\cdot y \mod p=REDC(REDC(\bar{x}\cdot \bar{y}))\\
\bar{x}&=REDC(x\cdot (RR \bmod p))\\
\bar{y}&=REDC(y\cdot (RR \bmod p))\\
\end{align*}</script><h4 id="2-1-4-小结"><a href="#2-1-4-小结" class="headerlink" title="2.1.4  小结"></a>2.1.4  小结</h4><p>上面介绍了三种模约简方法，模约简主要用于模乘中，这里主要对比分析一下巴雷特和蒙哥马利，至于朴素方案效率太低就不分析了。在FPGA上当一次处理位宽大于$16$-bit时蒙哥马利更具有优势，反之巴列特算法有优势。对CPU或者GPU版本没有看到相应的资料，不过从两种算法从时间复杂度上是类似的。连续模乘可能蒙哥马利的优势更大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202402282053440.png" alt="图 11 FPGA蒙哥马利与巴雷特对比" title="图 11 FPGA蒙哥马利与巴雷特对比">​</p>
<h3 id="2-2-root-power-预计算"><a href="#2-2-root-power-预计算" class="headerlink" title="2.2  root power 预计算"></a>2.2  root power 预计算</h3><p>算法3中需要反复执行$\varphi=\varphi \omega_m$，这里的m是当前合并轮次下每个单元的数据规模或者是蝶形运算的步长，$s $ 可以看作是当前合并轮数，$n$是输入规模，$l$是总的轮数。$\omega_m=\omega^{2^{n-s}}$,$s=\log_2m$。一共具有两种预计算方案</p>
<p><strong>方案一：</strong> 预计算$\omega$的幂到一个root power表$t$中，即$t[i]=\omega^i ,i\in[0,\frac{n}{2})$。对于给定的$j$和$m=2^s$，我们可以表示旋转因子$\varphi =t[j\cdot 2^{\alpha }], \alpha =n-s,j\in [0,2^{s-1})$。</p>
<p><strong>方案二：</strong> 计算每个粒度$s\in[1,n]$,单独的root power表：</p>
<script type="math/tex; mode=display">
T_s[i]=t[i\cdot 2^{n-s}]=(\omega^{2^{n-s}})^i, i\in [0,2^{s-1})</script><p>记$T_n=t$，$\sum_{s=1}^n|T_s|=\sum_{s=1}^n 2^{s-1}=2^n-1$。对于给定的$j$和$m=2^s$，我们可以表示旋转因子$\varphi =T[j]$。然后我们将将所有的$T_s$组成一个大的表$T$。</p>
<script type="math/tex; mode=display">
T_s[i]=T[(2^0+2^1+2^2+ \cdots +2^{s-2})+i]=T[2^{s-1}-1+i]</script><p>对于给定的$j$和$m=2^s$，我们可以表示旋转因子$\varphi =T[\beta + j],\beta=2^{s-1}-1=\frac{m}{2}-1$。</p>
<p>两种方式$T[\beta+j]$ 和$t[j \cdot 2^\alpha ]$，内层索引都是相同的，$\alpha$ 和 $\beta$表示循环中不变的表达式，在循环开始前计算一次。但是$T$，可以使用指针指向$T[\beta]$,</p>
<p>一步解引用。而$t$需要先位移后解引用。</p>
<p><strong>Four-step算法：</strong> 因为要用到所有的幂次，所以直接预计算所有的幂次，构建幂次表$T_<em>$即可。需要设计合适的索引。我的想法是利用折半引理，在对行或是对列的NTT中索引格式只需要在方案二的基础上进行细微改动即可，只需要乘上总规模$N$除当前NTT规模$n$的商即可，$T_</em>[(\beta+j)\frac{N}{n}]=T_*[\beta \mu+j\mu]$,只是这种方法会使得方案本一步完成的解引用，需要两步而且增加的是开销较高的乘法。至于列运算结束后的旋转因子矩阵直接按照输入索引去查询即可，因为输入矩阵和旋转因子因子矩阵是一一对应的。</p>
<h3 id="2-3-转置优化"><a href="#2-3-转置优化" class="headerlink" title="2.3 转置优化"></a>2.3 转置优化</h3><p>矩阵的转置有两种方式一种是out-place,一种是in-place。前者需要申请一块同等大小的空间，从而完成转置，即空间复杂度$O(R\times C)$。后一种，空间复杂度远小于$O(R\times C)$。这里主要讨论in-place转置方案，对于方阵很简单只需要交换$<i,j>$与$<j,i>$处的元素即可。</p>
<p>下面讨论$n\times cn$形式的矩阵转置，为了方便表示不妨取$c=2$。将一个$n\times 2n$的矩阵$M$拆分成两个$n\times n$的方阵$A$和$B$:</p>
<script type="math/tex; mode=display">
M=[A \quad B]</script><p>则转置表达为：</p>
<script type="math/tex; mode=display">
M^T=[A \quad B]^T=
\begin{bmatrix}
A^T\\\
B^T
\end{bmatrix}</script><p>定义$\phi(M)$: </p>
<script type="math/tex; mode=display">
\phi(M)=[A^T\quad B^T]</script><p>现在将两个子矩阵$A^T$，$B^T$的行用向量表示：</p>
<script type="math/tex; mode=display">
\phi(M)=[A^T\quad B^T]=
\begin{bmatrix}
\alpha_1 & \beta_1\\\
\cdots &\cdots \\\
\alpha_n & \beta_n
\end{bmatrix}
\longleftrightarrow<\alpha_1,\beta_1,\alpha_2,\beta_2,\cdots,\alpha_n,\beta_n ></script><script type="math/tex; mode=display">
M^T=
\begin{bmatrix}
A^T\\\
B^T
\end{bmatrix}
=
\begin{bmatrix}
\alpha_1 \\\
\cdots \\\
\alpha_n \\\  
\beta_1 \\\
\cdots\\\  
\beta_n
\end{bmatrix}
\longleftrightarrow <\alpha_1,\alpha_2,\cdots,\alpha_n,\beta_1,\beta_2,\cdots,\beta_n></script><p>所以我们可以通过某种方法$\rho$重新排列$\phi(M)$的索引，使其等于$M^T=\rho \phi(M)$，对于索引$i$的目标位置$j$满足：</p>
<script type="math/tex; mode=display">
j=\rho (i)=n \cdot  (i \bmod 2) + (i / 2) \quad i\in[0,2n)</script><p>下面探究对于列排布能否实现同样的作用， 首先我们定义对方阵的行进行索引重排为$\rho_r$,对其列进行索引成排为$\rho_c$。很明显对于一个矩阵A,满足一下关系：</p>
<script type="math/tex; mode=display">
(\rho_cX)^T=\rho_rX^T</script><p>我们已经证明:</p>
<script type="math/tex; mode=display">
M^T=\rho_r \phi(M)</script><p>现在令$M=\rho_c N$,即可获得：</p>
<script type="math/tex; mode=display">
\rho_r \phi(\rho_cN)=(\rho_cN)^T</script><script type="math/tex; mode=display">
\rho_r \phi(\rho_cN)=\rho_r(N)^T</script><script type="math/tex; mode=display">
\phi(\rho_cN)=N^T</script><p>现在证明对列进行排布同样可以完成相应的操作，只不过要现在哎方阵转置前进行列排布。对列进行排布对那内存更友好，需要$O(2n)$的额外空间。</p>
<p>对于$cn\times n$形式的矩阵，只需要对列执行$\rho^{-1}$然后对方阵转置就行。</p>
<h3 id="2-4-可能的优化"><a href="#2-4-可能的优化" class="headerlink" title="2.4  可能的优化"></a>2.4  可能的优化</h3><h4 id="2-4-1-位逆序省略"><a href="#2-4-1-位逆序省略" class="headerlink" title="2.4.1 位逆序省略"></a>2.4.1 位逆序省略</h4><p>我们回到最开始，我们引入DFT是为了进行多项式乘法：</p>
<script type="math/tex; mode=display">
A(x)\cdot B(x)=IDFT(DFT(A)\cdot DFT(B))</script><p>如果使用$DIF$完成$DFT$，使用$DIT$完成$IDFT$，我们就可以省略$DIF$最后的位逆序，以及$DIT$最开始的位逆序，紧挨着的两个位逆序可以省略。</p>
<h4 id="2-4-2-省略转置"><a href="#2-4-2-省略转置" class="headerlink" title="2.4.2 省略转置"></a>2.4.2 省略转置</h4><p>矩阵算法省略转置的原理与位逆序省略的原理相同，如果连续做$DFT$和$IDFT$，我们可以省略$DFT$最后的转置以及$IDFT$最开始的转置。</p>
<h4 id="2-4-3-合并"><a href="#2-4-3-合并" class="headerlink" title="2.4.3 合并"></a>2.4.3 合并</h4><ol>
<li>可以将对列之后乘旋转因子的操作合并到对列操作或者对行操作中，这样可以减少内存读写的次数。</li>
<li>对于$IDFT$可以将乘以$n^{-1}$,合并到四步$IDFT*$中，例如乘旋转因子的过程中。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]七海. 基础知识：FFT - 简单入门[EB/OL]//七海の参考書. (2021-03-29)[2024-01-21]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/">https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/</a>.</p>
<p>[2]快速数论变换（NTT）及蝴蝶操作构造详解[EB/OL]//知乎专栏. [2024-01-21]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/80297169">https://zhuanlan.zhihu.com/p/80297169</a>.</p>
<p>[3]Frigo M, Leiserson C E, Prokop H, et al. Cache-oblivious algorithms[J]. ACM Transactions on Algorithms (TALG), 2012, 8(1): 1-22. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.1145/2071379.2071383">https://doi.org/10.1145/2071379.2071383</a>.</p>
<p>[4]LESAVOUREY A, NEGRE C, PLANTARD T. Efficient Randomized Regular Modular Exponentiation using Combined Montgomery and Barrett Multiplications[C/OL]//ICETE: International Joint Conference on e-Business and Telecommunications: 4 [SECRYPT]. Lisbon, Portugal, 2016: 368-375[2024-02-28]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hal.science/hal-01330898">https://hal.science/hal-01330898</a>. DOI:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.5220/0005998503680375">10.5220/0005998503680375</a>.</p>
<p>[5]Finite Field Implementations[Z/OL]. [2024-01-26]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.google.com/presentation/d/1I5QS58LtA3iiiPiVHHcN7oufCoo8sIDh9UvnJHWjA2Q">https://docs.google.com/presentation/d/1I5QS58LtA3iiiPiVHHcN7oufCoo8sIDh9UvnJHWjA2Q</a>.</p>
<p>[6]RISC ZERO. Finite Field Implementations: Barrett &amp; Montgomery[Z/OL]. (2023-02-17)[2024-01-26]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.youtube.com/watch?v=hUl8ZB6hpUM">https://www.youtube.com/watch?v=hUl8ZB6hpUM</a>.</p>
<p>[7]AGARWAL R C, COOLEY J W. Fourier transform and convolution subroutines for the IBM 3090 Vector Facility[J/OL]. IBM Journal of Research and Development, 1986, 30(2): 145-161. DOI:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.1147/rd.302.0145">10.1147/rd.302.0145</a>.</p>
<p>[8]董晓算法. G41 快速傅里叶变换 FFT算法 多项式乘法_哔哩哔哩_bilibili[EB/OL]. [2024-01-21]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1Le4y1V78D/">https://www.bilibili.com/video/BV1Le4y1V78D/</a>.</p>
<p>[9]董晓算法. G43 快速数论变换 NTT算法_哔哩哔哩_bilibili[EB/OL]. [2024-01-21]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1a3411Z7vL/">https://www.bilibili.com/video/BV1a3411Z7vL/</a>.</p>
<p>[10]HEIDEAN M, JOHNSON D, BURRUS C. Gauss and the history of the fast fourier transform[J/OL]. IEEE ASSP Magazine, 1984, 1(4): 14-21. DOI:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.1109/MASSP.1984.1162257">10.1109/MASSP.1984.1162257</a>.</p>
<p>[11]COHEN H, FREY G, AVANZI R, 等. Handbook of Elliptic and Hyperelliptic Curve Cryptography[M/OL]. 0 版. Chapman and Hall/CRC, 2005[2024-02-26]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.taylorfrancis.com/books/9781420034981">https://www.taylorfrancis.com/books/9781420034981</a>. DOI:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.1201/9781420034981">10.1201/9781420034981</a>.</p>
<p>[12]Hardcaml Zprize[EB/OL]. [2024-01-30]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zprize.hardcaml.com/ntt-top-level.html">https://zprize.hardcaml.com/ntt-top-level.html</a>.</p>
<p>[13]IEEE Xplore Full-Text PDF:[EB/OL]. [2024-02-28]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4176858">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4176858</a>.</p>
<p>[14]Math &amp; Engineering[EB/OL]. [2024-02-22]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://xn--2-umb.com/">https://xn—2-umb.com/</a>.</p>
<p>[15]LIANG Z, ZHAO Y. Number Theoretic Transform and Its Applications in Lattice-based Cryptosystems: A Survey[M/OL]. arXiv, 2022[2024-01-30]. <a target="_blank" rel="noopener external nofollow noreferrer" href="http://arxiv.org/abs/2211.13546">http://arxiv.org/abs/2211.13546</a>.</p>
<p>[16]KNAUTH C, ADAS B, WHITFIELD D, 等. Practically efficient methods for performing bit-reversed permutation in C++11 on the x86-64 architecture[M/OL]. arXiv, 2017[2024-01-29]. <a target="_blank" rel="noopener external nofollow noreferrer" href="http://arxiv.org/abs/1708.01873">http://arxiv.org/abs/1708.01873</a>.</p>
<p>[17]DUPAQUIS V, VENELLI A. Redundant Modular Reduction Algorithms[C/OL]//PROUFF E. Smart Card Research and Advanced Applications. Berlin, Heidelberg: Springer, 2011: 102-114. DOI:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.1007/978-3-642-27257-8_7">10.1007/978-3-642-27257-8_7</a>.</p>
<p>[18]Knezevic M, Vercauteren F, Verbauwhede I. Speeding up Barrett and Montgomery modular multiplications[J]. IEEE Transactions on Comput, 2009, 2.<a href="assets/network-asset-bar_mont-20240412140014-xo4uyzq.pdf">bar_mont.pdf (kuleuven.be)</a></p>
<p>[19]KRAPIVENSKY V. Speeding up decimal multiplication[M/OL]. arXiv, 2020[2024-01-21]. <a target="_blank" rel="noopener external nofollow noreferrer" href="http://arxiv.org/abs/2011.11524">http://arxiv.org/abs/2011.11524</a>. DOI:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.48550/arXiv.2011.11524">10.48550/arXiv.2011.11524</a>.</p>
<p>[20]LONGA P, NAEHRIG M. Speeding up the Number Theoretic Transform for Faster Ideal Lattice-Based Cryptography[A/OL]. (2016)[2024-01-30]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://eprint.iacr.org/2016/504">https://eprint.iacr.org/2016/504</a>.</p>
<p>[21]REDUCIBLE. The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever?[Z/OL]. (2020-11-15)[2024-01-21]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.youtube.com/watch?v=h7apO7q16V0">https://www.youtube.com/watch?v=h7apO7q16V0</a>.</p>
<p>[22]LONGA P, NAEHRIG M. Speeding up the Number Theoretic Transform for Faster Ideal Lattice-Based Cryptography[A/OL]. (2016)[2024-07-11]. <a target="_blank" rel="noopener external nofollow noreferrer" href="https://eprint.iacr.org/2016/504">https://eprint.iacr.org/2016/504</a>.</p>
<p>‍</p>
<p>‍</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://qifeng.xyz">豈</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://qifeng.xyz/posts/a0adbc0f.html">http://qifeng.xyz/posts/a0adbc0f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://qifeng.xyz" target="_blank">豈風</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NTT/">NTT</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410102135290.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/a260d87d.html" title="Hugo+Github搭建个人主页"><img class="cover" src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410110957006.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hugo+Github搭建个人主页</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/android-chrome-512x512.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">豈</div><div class="author-info__description">分享研究生阶段学习和生活经历</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://resume.qifeng.xyz/"><i class="fa-solid fa-person"></i><span>个人简历</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinxiangkai" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yinxkai@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/wechat.png" target="_blank" title="Wechat"><i class="fa-brands fa-weixin" style="color: #7bb32e;"></i></a><a class="social-icon" href="/img/QQ.jpg" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #2ca7e0;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">路过的旅人你好啊！  内容来自各种网络或者书籍资源，如有侵权，请联系我删除！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">1 算法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%E5%BC%95%E5%85%A5"><span class="toc-text">1.1 多项式乘法引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-text">1.1.1 多项式的两种表示方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A"><span class="toc-text">系数表示法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E5%80%BC%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A"><span class="toc-text">点值表示法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95"><span class="toc-text">1.1.2 多项式乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E6%95%B0%E4%B9%98%E6%B3%95%EF%BC%9A"><span class="toc-text">系数乘法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E5%80%BC%E4%B9%98%E6%B3%95%EF%BC%9A"><span class="toc-text">点值乘法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E8%BD%AC%E6%8D%A2%E4%BC%98%E5%8C%96"><span class="toc-text">1.1.3 转换优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E5%8D%95%E4%BD%8D%E6%A0%B9%EF%BC%88%E5%A4%8D%E5%B9%B3%E9%9D%A2%EF%BC%89"><span class="toc-text">1.1.4 单位根（复平面）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#n-%E6%AC%A1%E5%8D%95%E4%BD%8D%E6%A0%B9%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-text">$n$ 次单位根的性质：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-DFT-%E4%B8%8E-IDFT"><span class="toc-text">1.2 $DFT$ 与 $IDFT$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88-DFT-%EF%BC%89"><span class="toc-text">1.2.1 离散傅里叶变换（$DFT$）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E9%80%86%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88-IDFT-%EF%BC%89"><span class="toc-text">1.2.2 逆离散傅里叶变换（$IDFT$）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E5%8C%96%EF%BC%88-FFT-%EF%BC%89"><span class="toc-text">1.3 快速傅里叶变化（$FFT$）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-FFT-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.1 $FFT$ 递归实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%9D%B6%E5%BD%A2%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">蝶形操作：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-FFT-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.2 $FFT$ 迭代实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E9%80%86%E5%BA%8F"><span class="toc-text">位逆序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">迭代算法实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%A7%86%E8%A7%92"><span class="toc-text">迭代的另一种视角</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%88-NTT-%EF%BC%89"><span class="toc-text">1.4 快速数论变换（$NTT$）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-text">1.4.1 数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-text">欧拉函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-text">欧拉定理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-text">费马小定理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B6"><span class="toc-text">阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9"><span class="toc-text">原根</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">原根的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%A8%A1%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">原根与模数的选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-NTT-%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.4.2 $NTT$ 的递归实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-NTT-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.4.3 $NTT$ 的迭代实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%9F%A9%E9%98%B5DFT%E2%80%8B%E7%AE%97%E6%B3%95"><span class="toc-text">1.5  矩阵DFT​算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Four-step-DFT"><span class="toc-text">Four-step DFT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Six-step-DFT"><span class="toc-text">Six-step DFT</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-NTT-%E8%AE%BE%E8%AE%A1"><span class="toc-text">2 NTT 设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E7%BA%A6%E7%AE%80"><span class="toc-text">2.1 模约简</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%9C%B4%E7%B4%A0%E6%96%B9%E6%A1%88"><span class="toc-text">2.1.1 朴素方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Barrett-%E7%BA%A6%E7%AE%80"><span class="toc-text">2.1.2 Barrett 约简</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Montgomery-%E7%BA%A6%E7%AE%80"><span class="toc-text">2.1.3  Montgomery 约简</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E7%BA%A6%E7%AE%80"><span class="toc-text">蒙哥马利约简</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E5%9F%9F"><span class="toc-text">蒙哥马利域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E6%A8%A1%E4%B9%98"><span class="toc-text">蒙哥马利模乘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%B0%8F%E7%BB%93"><span class="toc-text">2.1.4  小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-root-power-%E9%A2%84%E8%AE%A1%E7%AE%97"><span class="toc-text">2.2  root power 预计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BD%AC%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="toc-text">2.3 转置优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">2.4  可能的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E4%BD%8D%E9%80%86%E5%BA%8F%E7%9C%81%E7%95%A5"><span class="toc-text">2.4.1 位逆序省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%9C%81%E7%95%A5%E8%BD%AC%E7%BD%AE"><span class="toc-text">2.4.2 省略转置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%90%88%E5%B9%B6"><span class="toc-text">2.4.3 合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a1546b3a.html" title="CUDA 环境配置"><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410111005353.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CUDA 环境配置"/></a><div class="content"><a class="title" href="/posts/a1546b3a.html" title="CUDA 环境配置">CUDA 环境配置</a><time datetime="2024-10-10T07:55:04.000Z" title="发表于 2024-10-10 15:55:04">2024-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1ea709cb.html" title="Shared Memory 大小限制"><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410111005353.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shared Memory 大小限制"/></a><div class="content"><a class="title" href="/posts/1ea709cb.html" title="Shared Memory 大小限制">Shared Memory 大小限制</a><time datetime="2024-10-05T13:42:01.000Z" title="发表于 2024-10-05 21:42:01">2024-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b49c4352.html" title="远程连接服务器"><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410111000617.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="远程连接服务器"/></a><div class="content"><a class="title" href="/posts/b49c4352.html" title="远程连接服务器">远程连接服务器</a><time datetime="2024-09-12T08:34:47.000Z" title="发表于 2024-09-12 16:34:47">2024-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/89d9e386.html" title="NVTX"><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410111005353.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NVTX"/></a><div class="content"><a class="title" href="/posts/89d9e386.html" title="NVTX">NVTX</a><time datetime="2024-09-11T09:55:07.000Z" title="发表于 2024-09-11 17:55:07">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed5d8a1b.html" title="TensorCore WMMA 编程"><img src="https://cdn.jsdelivr.net/gh/yinxiangkai/ImageBed@main/202410111005353.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TensorCore WMMA 编程"/></a><div class="content"><a class="title" href="/posts/ed5d8a1b.html" title="TensorCore WMMA 编程">TensorCore WMMA 编程</a><time datetime="2024-07-08T02:01:16.000Z" title="发表于 2024-07-08 10:01:16">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 豈</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams'
        },
        chtml: {
          scale: 1.1
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'cee9a7299c7ed214f720',
      clientSecret: 'b6b040a40001c2d2129236573ac7695d3fec20e3',
      repo: 'yinxiangkai.github.io',
      owner: 'yinxiangkai',
      admin: ['yinxiangkai'],
      id: '1ac99613e44a9d06749187cd2f863278',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.14.0-b3"></script></div></div></body></html>